#!/bin/bash

# Initialize variables to store flag values
arg_d=false
arg_p=false
arg_s=false

# Loop to parse command-line options using getopts
while getopts ":dps" opt; do
  case $opt in
    d)
      arg_d=true
      ;;
    p)
      arg_p=true
      ;;
    s)
      arg_s=true
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
  esac
done

# Check if neither or both flags are set
if { [ "$arg_d" = "false" ] && [ "$arg_p" = "false" ]; } || { [ "$arg_d" = "true" ] && [ "$arg_p" = "true" ]; }; then
  echo "Error: Either -d or -p must be specified, but not both." >&2
  exit 1
fi

# If -p flag is set, check if the current git branch is "prod"
if [ "$arg_p" = "true" ]; then
  current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)

  if [ $? -ne 0 ]; then
    echo "Error: Failed to determine the current Git branch." >&2
    exit 1
  elif [ "$current_branch" != "prod" ]; then
    echo "Error: The -p option can only be used when the current Git branch is named 'prod'." >&2
    exit 1
  fi
fi

# Remove the flags that have already been parsed
shift $((OPTIND-1))

# Set.start-app-environment variables based on the selected flag
if [[ "$arg_d" == "true" ]]; then
  # Extract the development section from the .start-app-env file and set the.start-app-environment variables
  grep -A1000 '^# Development' .start-app-env | grep -B1000 '^# Production' | sed -e '1d;$d' | while read -r line; do
    if [[ ! "$line" =~ ^#.* ]] && [[ -n "$line" ]]; then
      export "$line"
	  var_name="${line%%=*}"
      echo "Exported: $var_name=${!var_name}"
    fi
  done

elif [[ "$arg_p" == "true" ]]; then
  # Extract the production section from the .start-app-env file and set the.start-app-environment variables
  grep -A1000 '^# Production' .start-app-env | while read -r line; do
    # Ignore comments
    if [[ ! "$line" =~ ^#.* ]] && [[ -n "$line" ]]; then
      export "$line"
	  var_name="${line%%=*}"
      echo "Exported: $var_name=${!var_name}"
    fi
  done

  # Fetch the local IPv4 address using the AWS Metadata Service
  LOCAL_IPV4=$(curl -s --connect-timeout 5 http://169.254.169.254/latest/meta-data/local-ipv4)
  # Check if the curl command was successful
  if [[ $? -eq 0 ]] && [[ -n "$LOCAL_IPV4" ]]; then
    # Set the IP address as the MYSQL_HOST_IP_OR_HOSTNAME environment variable
    export MYSQL_HOST_IP_OR_HOSTNAME=$LOCAL_IPV4
	var_name=MYSQL_HOST_IP_OR_HOSTNAME
	echo "Changed $var_name to ${!var_name}"
  else
    # Print an error message and exit with status code 1
    echo "Error: Unable to fetch the local IPv4 address from the AWS Metadata Service." >&2
    exit 1
  fi
fi

# Create a temporary environment file
temp_env_file=$(mktemp)

# Save the relevant environment variables to the temporary file
env | grep -E 'MYSQL_DATABASE|MYSQL_USER|MYSQL_PASSWORD|MYSQL_HOST_IP_OR_HOSTNAME|NODE_ENV' > "$temp_env_file"

# Remove any Docker containers that aren't in use
if [[ "$arg_s" == "true" ]]; then
  sudo docker-compose -f docker-compose.prod.yml --env-file "$temp_env_file" down
  sudo docker-compose -f docker-compose.dev.yml --env-file "$temp_env_file" down
else
  docker-compose -f docker-compose.prod.yml --env-file "$temp_env_file" down
  docker-compose -f docker-compose.dev.yml --env-file "$temp_env_file" down
fi

# Run the sudo docker-compose command based on the selected flag
if [[ "$arg_d" == "true" ]]; then
  if [[ "$arg_s" == "true" ]]; then
    sudo docker-compose -f docker-compose.dev.yml --env-file "$temp_env_file" up --build
  else
	docker-compose -f docker-compose.dev.yml --env-file "$temp_env_file" up --build
  fi
elif [[ "$arg_p" == "true" ]]; then
  if [[ "$arg_s" == "true" ]]; then
    sudo docker-compose -f docker-compose.prod.yml --env-file "$temp_env_file" up --build
  else
    docker-compose -f docker-compose.prod.yml --env-file "$temp_env_file" up --build	
  fi
fi

# Remove the temporary environment file
rm "$temp_env_file"

